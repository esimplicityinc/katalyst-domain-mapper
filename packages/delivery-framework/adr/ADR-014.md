---
id: ADR-014
title: "Hexagonal Architecture for All Bounded Contexts"
status: accepted
category: architecture
scope: "packages/intelligence/api, packages/foe-api"
created: "2026-02-12"
updated: "2026-02-12"
author: "Katalyst Team"
supersedes: ""
superseded_by: ""
---

# ADR-014: Hexagonal Architecture for All Bounded Contexts

## Status

**Accepted** - 2026-02-12

## Context

This artifact was created retroactively to document work completed on 2026-02-12.

ROAD-027 (Hexagonal Refactoring of Domain-Modeling Bounded Context) revealed that the domain-modeling bounded context had devolved into a **772-line fat controller** with raw Drizzle ORM queries inline in route handlers. There was no domain layer, no port interfaces, no adapter abstractions, and no use cases. The architecture score for this context was **52/100** — the lowest in the system.

Meanwhile, other bounded contexts (Reports, Governance, Taxonomy) already followed hexagonal architecture patterns established in ADR-003 and ADR-004. The inconsistency was growing with every new feature, and the domain-modeling context was becoming the de facto template for new developers who copied its patterns.

### Problems with Previous Approach

1. **Fat controller anti-pattern**: 772 lines of mixed HTTP handling, validation, database queries, and business logic in a single route file
2. **No domain layer**: Domain rules were scattered across route handlers, making them invisible and duplicated
3. **Direct ORM coupling**: Raw Drizzle queries in route handlers meant changing the database required touching every route
4. **Untestable business logic**: Could not test domain rules without spinning up the full HTTP stack and database
5. **Inconsistent codebase**: Some bounded contexts followed hexagonal patterns, others didn't — no clear standard
6. **Copy-paste propagation**: New developers used the fat controller as a template, spreading the anti-pattern

## Decision

**ALL bounded contexts MUST follow hexagonal architecture**: Domain objects → Port interfaces → Adapter implementations → Use cases → Thin HTTP route handlers. Container wiring injects dependencies. No direct database access from routes.

### Implementation Details

#### Standard Directory Structure Per Bounded Context

```
domain/{context}/
  ├── DomainObject.ts        — domain validation, factory methods, invariants
  ├── DomainErrors.ts        — typed error classes (NotFound, InvalidState, etc.)
ports/
  └── {Context}Repository.ts — interface defining persistence operations
adapters/sqlite/
  └── {Context}RepositorySQLite.ts — Drizzle ORM implementation of port
usecases/{context}/
  ├── CreateX.ts             — create use case with domain validation
  ├── GetX.ts                — single-item retrieval with error handling
  ├── ListX.ts               — collection retrieval with filtering
  └── DeleteX.ts             — deletion with referential integrity checks
http/routes/v1/
  └── {context}.ts           — thin HTTP layer (<250 lines), delegates to use cases
```

#### Key Rules

1. **Route handlers** only handle HTTP concerns: parse request, call use case, format response
2. **Use cases** orchestrate domain logic: validate inputs, call repositories, enforce business rules
3. **Domain objects** encapsulate invariants: factory methods with validation, no anemic models
4. **Port interfaces** define contracts: repository interfaces with typed return values
5. **Adapters** implement ports: one adapter per persistence technology per bounded context
6. **Container wiring** injects adapters into use cases, use cases into route handlers

#### Domain Error Hierarchy

```typescript
abstract class DomainError extends Error {
  abstract readonly statusCode: number;
}

class NotFoundError extends DomainError {
  readonly statusCode = 404;
}

class ValidationError extends DomainError {
  readonly statusCode = 400;
}

class ConflictError extends DomainError {
  readonly statusCode = 409;
}
```

Route handlers catch `DomainError` subtypes and map them to HTTP responses, keeping error semantics in the domain layer.

#### Evidence: ROAD-027 Results

| Metric | Before | After |
|--------|--------|-------|
| Architecture Score | 52/100 | 97.5/100 |
| Route file lines | 772 | ~200 |
| Domain objects | 0 | 3 (with validation) |
| Port interfaces | 0 | 1 |
| Adapter implementations | 0 | 1 |
| Use cases | 0 | 5 |
| BDD tests passing | unknown | 47 |
| Test isolation | impossible | full (mocked ports) |

## Consequences

### Positive

1. **Independent testing**: Use cases and domain objects testable without HTTP or database
2. **Swappable persistence**: Change from SQLite to PostgreSQL by implementing a new adapter — no use case changes
3. **Domain validation**: Business rules live in domain objects, enforced consistently regardless of entry point
4. **Consistent codebase patterns**: Every bounded context follows the same structure — reduced cognitive load when switching contexts
5. **Clear responsibility boundaries**: Each layer has a single job, making code reviews faster and more focused
6. **Onboarding clarity**: New developers learn one pattern, apply it everywhere
7. **Refactoring safety**: Changes to one layer don't cascade (port interface is the contract boundary)

### Negative

1. **More files per bounded context**: 5-10 files vs 1 fat route file — higher file count, more navigation
2. **Slightly steeper initial onboarding curve**: Developers unfamiliar with hexagonal architecture need to learn the pattern
3. **Boilerplate for simple CRUD**: Simple entities without domain logic still require the full layer stack
4. **Indirection cost**: Following a request through 4 layers (route → use case → domain → adapter) requires more jumping

### Risks

1. **Over-engineering simple CRUD contexts**: Mitigated by keeping use cases thin when no domain logic is needed — use cases can be pass-through delegates
2. **Inconsistent adoption**: Mitigated by making this an ADR (mandatory) and using ROAD-027 as the reference implementation
3. **Port interface drift**: Port interfaces may accumulate methods over time — mitigated by periodic review and interface segregation

## Related

- **ROAD-027** — Hexagonal Refactoring of Domain-Modeling Bounded Context (trigger for this decision)
- **CAP-020** — Domain Modeling CRUD capabilities
- **ADR-003** — Hexagonal Architecture (original decision for initial bounded contexts)
- **ADR-004** — Ports & Adapters (detailed port/adapter patterns)

---

**Template Version**: 1.0.0
**Last Updated**: 2026-02-12
