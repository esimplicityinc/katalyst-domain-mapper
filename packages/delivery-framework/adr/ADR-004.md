---
id: ADR-004
title: "Elysia + Drizzle ORM on Bun for API Layer"
status: accepted
category: infrastructure
scope: "@foe/api"
created: "2026-02-06"
updated: "2026-02-06"
author: "Katalyst Team"
supersedes: ""
superseded_by: ""
---

# ADR-004: Elysia + Drizzle ORM on Bun for API Layer

## Status

**Accepted** - 2026-02-06

## Context

The `@foe/api` package needs an HTTP framework and a persistence layer. Requirements:

1. **HTTP Framework**: REST API with JSON responses, CORS, Swagger docs, middleware support, type-safe route definitions
2. **Persistence**: Embedded database (no external service dependencies for development), SQL support, type-safe queries, migration management
3. **Runtime Compatibility**: Must run natively on Bun (ADR-001)
4. **Performance**: API response times &lt;200ms (NFR-PERF-002)

The API serves scan reports, governance snapshots, and domain model data. It orchestrates background scan jobs via Docker and provides endpoints for the web UI.

## Decision

Use **Elysia** as the HTTP framework and **Drizzle ORM** over **`bun:sqlite`** for persistence.

**Elysia** (v1.4):
- Bun-native HTTP framework with the fastest benchmarks on Bun runtime
- Type-safe route definitions with automatic OpenAPI/Swagger generation (`@elysiajs/swagger`)
- Built-in CORS support (`@elysiajs/cors`)
- Plugin-based middleware architecture
- End-to-end type safety from route definition to response

**Drizzle ORM** (v0.45):
- Type-safe SQL query builder (no raw SQL strings)
- Schema-as-code with `drizzle-kit` for migrations
- Direct `bun:sqlite` driver (no Node.js native addon overhead)
- Lightweight (~30KB) compared to Prisma (~10MB engine binary)

**`bun:sqlite`**:
- Built into Bun runtime (zero dependencies)
- File-based database (no external service to manage)
- WAL mode for concurrent read performance

## Consequences

### Positive

- Elysia on Bun is one of the fastest HTTP frameworks available (~100K+ req/s for simple endpoints)
- Drizzle's SQL-like API is familiar to developers who know SQL
- SQLite requires zero infrastructure setup (no Docker database container)
- Swagger documentation is auto-generated from route definitions
- Type safety flows from Drizzle schema → queries → Elysia routes → API responses

### Negative

- Elysia has a smaller community than Express/Fastify; fewer middleware options
- SQLite limits concurrent write throughput (WAL mode mitigates but doesn't eliminate)
- Drizzle is newer than Prisma/TypeORM; some edge cases may require raw SQL
- Migration to PostgreSQL would require rewriting Drizzle schema definitions (different dialect)

### Neutral

- SQLite database file is stored locally (no network latency for queries)
- Elysia's plugin model is different from Express middleware (learning curve for Express users)
- Drizzle schema definitions live alongside adapter code in `src/adapters/sqlite/`

## Alternatives Considered

### Alternative 1: Express + Prisma on Node.js

**Description**: Industry-standard Node.js HTTP framework with the most popular ORM.

**Pros**:
- Largest ecosystem and community
- Prisma has excellent DX (schema-first, auto-generated client)
- Battle-tested in production

**Cons**:
- Express is slow compared to Bun-native frameworks
- Prisma engine binary is ~10MB; adds startup time
- Prisma does not support `bun:sqlite` natively
- Conflicts with ADR-001 (Bun as runtime)

**Why Rejected**: Performance overhead and incompatibility with Bun-native APIs. Prisma's engine binary is unnecessarily large for an embedded database use case.

### Alternative 2: Hono + better-sqlite3

**Description**: Lightweight, multi-runtime HTTP framework with Node.js SQLite binding.

**Pros**:
- Hono is multi-runtime (Bun, Node, Deno, Cloudflare Workers)
- better-sqlite3 is synchronous (simpler API)
- Both are lightweight

**Cons**:
- Hono lacks built-in Swagger generation
- better-sqlite3 is a Node.js native addon (requires compilation on Bun)
- Less type-safe than Elysia's end-to-end inference

**Why Rejected**: Elysia's Bun-native design and built-in Swagger support provide better DX for this project.

### Alternative 3: Fastify + Knex

**Description**: High-performance Node.js framework with a mature SQL query builder.

**Pros**:
- Fastify is fast and has a large plugin ecosystem
- Knex supports many databases with the same API

**Cons**:
- Fastify is optimized for Node.js, not Bun
- Knex is a query builder, not a full ORM (no type inference from schema)
- Would need separate type definitions

**Why Rejected**: Bun-native Elysia outperforms Fastify on Bun runtime. Drizzle provides better TypeScript integration than Knex.

## Implementation Notes

- Elysia app is created in `src/http/app.ts` with plugins for CORS, Swagger, and error handling
- Drizzle schemas are defined in `src/adapters/sqlite/schema/` (one file per table)
- Migrations managed via `drizzle-kit` (`bun run db:migrate`)
- Database file location configurable via environment variable (`DATABASE_PATH`)
- The API adapters in `src/adapters/sqlite/` are the only code that knows about Drizzle; ports and use cases are framework-agnostic (ADR-003)

## References

- [Elysia Documentation](https://elysiajs.com/)
- [Drizzle ORM Documentation](https://orm.drizzle.team/)
- [@foe/api package](../../packages/foe-api/)
- [ADR-001: Bun Workspaces](./ADR-001.md)
- [ADR-003: Hexagonal Architecture](./ADR-003.md)

## Compliance

This ADR affects the following areas:
- **Road Items**: ROAD-005
- **NFRs**: NFR-PERF-002 (API Response Time), NFR-SEC-001 (Credential Protection)
- **BDD Scenarios**: API feature files in `stack-tests/features/api/`

---

**Template Version**: 1.0.0
**Last Updated**: 2026-02-06
