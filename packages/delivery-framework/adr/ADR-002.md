---
id: ADR-002
title: "Zod as Single Source of Truth for Validation"
status: accepted
category: architecture
scope: "@foe/schemas"
created: "2026-02-06"
updated: "2026-02-06"
author: "Katalyst Team"
supersedes: ""
superseded_by: ""
---

# ADR-002: Zod as Single Source of Truth for Validation

## Status

**Accepted** - 2026-02-06

## Context

The Katalyst Domain Mapper pipeline processes data across multiple boundaries: markdown frontmatter is parsed by CLI tools, validated, stored in JSON indices, ingested by the API, persisted to SQLite, served via REST, and consumed by web UIs. Data integrity must be enforced at every boundary.

TypeScript's type system is compile-time only -- it provides no runtime guarantees. If a markdown file has a malformed frontmatter field, or an API request sends an invalid payload, TypeScript types alone cannot catch these errors. The project needed a solution that provides both:

1. **Runtime validation** at data ingest boundaries
2. **TypeScript type inference** from the same source, avoiding type/validator divergence

## Decision

Use **Zod** as the canonical schema definition library across all packages. All data structures are defined as Zod schemas first; TypeScript types are inferred via `z.infer<typeof Schema>`.

Key aspects:
- `@foe/schemas` package is the single source of truth for all schemas (scan, field-guide, governance, DDD)
- Every package imports types from `@foe/schemas` -- no local type redefinitions
- Runtime validation occurs at every ingest boundary (frontmatter parsing, API request handling, JSON file loading)
- Zod's `.parse()` and `.safeParse()` methods provide structured error reporting

## Consequences

### Positive

- Single source of truth: change the Zod schema, and both runtime validation and TypeScript types update automatically
- Structured, human-readable error messages when validation fails (field paths, expected vs. received)
- Composable schemas: governance schemas extend common schemas, reducing duplication
- Tree-shakeable: packages only import the schemas they need
- Schema validation benchmarks at ~5ms per report, well within performance budgets

### Negative

- Adds a runtime dependency (~50KB) to every package that validates data
- Zod's error messages can be verbose for deeply nested schemas
- Learning curve for team members unfamiliar with Zod's API (refinements, transforms, discriminated unions)
- Breaking schema changes require coordinated updates across all consuming packages

### Neutral

- Zod schemas serve as living documentation of data contracts
- The `@foe/schemas` build output is 141KB bundled with 45 TypeScript declaration files

## Alternatives Considered

### Alternative 1: TypeScript-Only Interfaces

**Description**: Define interfaces in TypeScript; no runtime validation.

**Pros**:
- Zero runtime overhead
- No additional dependency

**Cons**:
- No runtime validation at boundaries
- Corrupt data silently propagates through the system
- API consumers can send anything

**Why Rejected**: Unacceptable risk for a system that parses markdown frontmatter from untrusted sources and exposes a REST API.

### Alternative 2: JSON Schema + Code Generation

**Description**: Define schemas in JSON Schema format; generate TypeScript types and validators.

**Pros**:
- Industry-standard schema format
- IDE autocomplete support for JSON files
- Many language bindings available

**Cons**:
- Code generation step adds build complexity
- JSON Schema is verbose and less ergonomic than TypeScript-native solutions
- Generated code often needs manual adjustment
- Two sources of truth (schema + generated code) can diverge

**Why Rejected**: Code generation introduces a build step and divergence risk. Zod's TypeScript-native approach is more ergonomic and eliminates the generation step.

### Alternative 3: io-ts

**Description**: Use io-ts for runtime type validation with fp-ts integration.

**Pros**:
- Mature library with strong TypeScript support
- Functional programming style with Either types

**Cons**:
- Requires fp-ts dependency (functional programming paradigm not used elsewhere in project)
- More complex API than Zod
- Smaller community and fewer examples

**Why Rejected**: fp-ts dependency and functional style would be inconsistent with the project's imperative/OOP patterns. Zod's API is more approachable.

## Implementation Notes

- Schema modules are organized by domain: `scan/`, `field-guide/`, `governance/`, `ddd/`
- Each module has an `index.ts` re-exporting all schemas and inferred types
- Cross-references between artifacts use format-validated strings (e.g., `z.string().regex(/^CAP-\d{3}$/)`)
- Referential integrity (do referenced IDs actually exist?) is deferred to the index builder, not the schemas

## References

- [Zod Documentation](https://zod.dev/)
- [@foe/schemas package](../../packages/foe-schemas/)
- [Governance Schemas Plan](../plans/governance-schemas.md)
- [DDD Schemas Plan](../plans/ddd-schemas.md)

## Compliance

This ADR affects the following areas:
- **Road Items**: ROAD-002, ROAD-003
- **NFRs**: NFR-REL-001 (Schema Validation at Boundaries)
- **BDD Scenarios**: Feature files for schema validation (ROAD-002/003 BDD scope)

---

**Template Version**: 1.0.0
**Last Updated**: 2026-02-06
