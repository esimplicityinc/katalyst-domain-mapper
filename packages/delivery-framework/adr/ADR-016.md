---
id: ADR-016
title: "Multi-Adapter Persistence for Taxonomy"
status: accepted
category: architecture
scope: "packages/intelligence/api"
created: "2026-02-17"
updated: "2026-02-17"
author: "Katalyst Team"
supersedes: ""
superseded_by: ""
---

# ADR-016: Multi-Adapter Persistence for Taxonomy

## Status

**Accepted** - 2026-02-17

## Context

This artifact was created retroactively to document work completed on 2026-02-17.

Taxonomy management — the hierarchical structure of nodes, environments, layer types, capabilities, capability relationships, actions, stages, and tools — is a foundational data model for the Katalyst platform. It defines what systems exist, how they relate, and what capabilities they provide. Two distinct consumption patterns emerged:

1. **API-driven operations**: The Intelligence API needs fast CRUD operations for taxonomy entities — creating, reading, updating, deleting individual records with sub-100ms response times. This requires a relational database with indexed queries.

2. **GitOps workflows**: Platform engineering teams want to manage taxonomy declaratively — editing YAML files in a Git repository, reviewing changes in pull requests, and having CI pipelines ingest updates. This requires file-based persistence that can be version-controlled.

### Problems with Previous Approach

1. **Bulk-only ingestion**: The only way to update taxonomy was a `POST /api/v1/taxonomy` endpoint that accepted a full JSON snapshot — replacing the entire taxonomy atomically. No incremental updates.
2. **No CRUD endpoints**: Could not create, update, or delete individual taxonomy entities via the API
3. **No file-based persistence**: No support for YAML-based taxonomy definitions that could live in Git
4. **All-or-nothing updates**: Changing one capability required re-uploading the entire taxonomy snapshot
5. **No referential integrity on partial updates**: The snapshot approach validated the whole graph at once, but there was no mechanism for validating incremental changes against existing data

## Decision

The `TaxonomyRepository` port interface is designed to support **both database and file adapters**. Both will implement the same port interface, enabling the route handler to work with either adapter via dependency injection.

### Implementation Status

**Phase 1 (Complete)**: The existing `TaxonomyRepositorySQLite` adapter has been extended with snapshot ingestion, query methods, and the port interface foundation. Entity-level CRUD methods are defined in the port specification below but not yet all wired as HTTP endpoints — bulk snapshot ingestion remains the primary write path.

**Phase 2 (Planned)**: Entity-level CRUD endpoints for all 8 types and the `TaxonomyRepositoryFile` adapter for GitOps workflows.

### Implementation Details

#### Port Interface

```typescript
interface TaxonomyRepository {
  // Nodes
  createNode(node: CreateNodeInput): Promise<TaxonomyNode>;
  getNode(id: string): Promise<TaxonomyNode | null>;
  listNodes(filter?: NodeFilter): Promise<TaxonomyNode[]>;
  updateNode(id: string, updates: UpdateNodeInput): Promise<TaxonomyNode>;
  deleteNode(id: string, options?: DeleteOptions): Promise<void>;

  // Environments, LayerTypes, Capabilities, etc.
  // ... same CRUD pattern for each entity type

  // Bulk operations (backward compatibility)
  ingestSnapshot(snapshot: TaxonomySnapshot): Promise<IngestResult>;

  // Referential integrity
  validateReferences(entityType: string, id: string): Promise<ValidationResult>;
}
```

#### Database Adapter: TaxonomyRepositorySQLite

- Implements `TaxonomyRepository` using Drizzle ORM against SQLite
- Optimized for fast indexed queries (sub-10ms reads)
- Supports transactions for multi-entity operations
- Cascade delete with configurable behavior (error, orphan, cascade)
- Used by the API for runtime operations

#### File Adapter: TaxonomyRepositoryFile

- Implements `TaxonomyRepository` using YAML files on disk
- Directory structure mirrors entity types:

```
taxonomy/
  ├── nodes/*.yaml           — system/subsystem definitions
  ├── environments/*.yaml    — dev/staging/prod configurations
  ├── layer-types/*.yaml     — architectural layer definitions
  ├── capabilities/*.yaml    — capability definitions
  ├── capability-rels/*.yaml — capability-to-node relationships
  ├── actions/*.yaml         — action definitions
  ├── stages/*.yaml          — lifecycle stage definitions
  └── tools/*.yaml           — tool definitions
```

- Each YAML file represents one entity (one file per node, capability, etc.)
- File names derived from entity slugs (e.g., `capabilities/foe-scanning.yaml`)
- Validates parent references against other files in the directory
- Used for GitOps import workflows and CI/CD ingestion

#### Referential Integrity

Both adapters enforce referential integrity:

- **Parent references**: A capability must reference an existing node
- **Relationship validity**: Capability relationships must reference valid capability and node IDs
- **Orphan prevention**: Deleting a node checks for dependent capabilities, relationships, etc.
- **Cascade options**: `DeleteOptions` supports `{ cascade: 'error' | 'orphan' | 'cascade' }`

#### Backward Compatibility

The existing bulk snapshot endpoint (`POST /api/v1/taxonomy`) continues to work alongside the new CRUD endpoints. Internally, it delegates to the same `TaxonomyRepository` port, using `ingestSnapshot()` which performs a transactional replace-all operation. Existing consumers experience zero breaking changes.

#### New CRUD Endpoints

```
POST   /api/v1/taxonomy/nodes          — create node
GET    /api/v1/taxonomy/nodes           — list nodes (with filtering)
GET    /api/v1/taxonomy/nodes/:id       — get single node
PUT    /api/v1/taxonomy/nodes/:id       — update node
DELETE /api/v1/taxonomy/nodes/:id       — delete node

# Same pattern for: environments, layer-types, capabilities,
#   capability-rels, actions, stages, tools
```

## Consequences

### Positive

1. **Incremental API updates**: Create, update, or delete individual taxonomy entities without re-uploading the entire snapshot
2. **GitOps-friendly**: Platform teams can manage taxonomy as YAML in version control with PR-based review workflows
3. **Flexible persistence**: Same port interface, different adapters — choose the right persistence strategy per use case
4. **Backward compatible**: Existing snapshot ingestion continues working unchanged
5. **Referential integrity**: Both adapters validate parent references and prevent orphaned records
6. **Hexagonal alignment**: Multi-adapter pattern is a natural extension of ADR-014's hexagonal mandate — the port interface enables adapter swapping without use case changes

### Negative

1. **Two adapters to maintain**: Bug fixes and new features must be implemented in both SQLite and File adapters
2. **Potential sync drift**: If both adapters are used simultaneously against different data sources, they may diverge
3. **More complex testing**: Integration tests needed for both adapters, plus cross-adapter consistency tests
4. **File adapter performance**: YAML file I/O is slower than SQLite for large taxonomies (100+ entities per type)

### Risks

1. **Sync conflicts between file and DB**: Mitigated by treating the file adapter as a **source-of-truth import** mechanism and the DB as the **operational store**. The file adapter reads YAML and ingests into the DB — they are not bidirectional mirrors.
2. **YAML schema evolution**: If the taxonomy schema changes, existing YAML files may become invalid — mitigated by schema versioning in YAML frontmatter and migration tooling.
3. **Large taxonomy performance**: File adapter reads all files on each operation — mitigated by caching and limiting file adapter use to import workflows (not runtime queries).

## Related

- **ROAD-041** — Taxonomy CRUD API and multi-adapter persistence
- **CAP-019** — Taxonomy management capability
- **CAP-013** — Taxonomy ingestion capability (original snapshot-based)
- **ADR-014** — Hexagonal Architecture for All Bounded Contexts (enables the multi-adapter pattern)

---

**Template Version**: 1.0.0
**Last Updated**: 2026-02-17
