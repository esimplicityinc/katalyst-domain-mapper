---
id: ADR-007
title: "Docker Multi-Stage Builds with Pre-Baked Indices"
status: accepted
category: infrastructure
scope: "@foe/scanner"
created: "2026-02-06"
updated: "2026-02-06"
author: "Katalyst Team"
supersedes: ""
superseded_by: ""
---

# ADR-007: Docker Multi-Stage Builds with Pre-Baked Indices

## Status

**Accepted** - 2026-02-06

## Context

The `@foe/scanner` package runs as a Docker container that analyzes repositories using AI agents. The scanner requires pre-built JSON indices from the Field Guide (methods, observations, keywords) and governance artifacts. These indices:

1. Take ~2 seconds to build from 133+ markdown files
2. Require build tools (Bun, TypeScript, parsers) that are unnecessary at runtime
3. Must be available immediately when the container starts (no startup delay)
4. Should not change between scans (they represent the assessment framework, not the target repo)

The runtime container only needs the OpenCode CLI, the AI agent definitions, and the pre-built JSON indices.

## Decision

Use **Docker multi-stage builds** to separate index building from the runtime environment:

**Stage 1 (Builder):** `oven/bun:1` base image
- Installs dependencies for `@foe/schemas` and `@foe/field-guide-tools`
- Runs `bunx foe-field-guide build` to produce `methods-index.json` and `observations-index.json`
- Future: also runs `bunx foe-field-guide build:governance` to produce `governance-index.json` (ROAD-006)

**Stage 2 (Runtime):** `debian:bookworm-slim` base image
- Installs only the OpenCode CLI
- Copies pre-built JSON indices from Stage 1
- Copies AI agent markdown files
- No Bun, no TypeScript, no build tools

The runtime image is lean (~500MB, primarily OpenCode + its dependencies) and starts instantly with all indices available.

## Consequences

### Positive

- Runtime image is significantly smaller than a full build image
- Zero startup delay: indices are pre-built at image build time
- Separation of build and runtime concerns reduces the attack surface
- Deterministic: the same Dockerfile produces the same indices (reproducible builds)
- Adding governance indices (ROAD-006) follows the same pattern

### Negative

- Docker image must be rebuilt when Field Guide content changes (even though the scanner code hasn't changed)
- Multi-stage builds are slightly more complex to debug than single-stage
- The builder stage includes all monorepo dependencies even though only two packages are needed

### Neutral

- Image size is ~500MB, dominated by OpenCode CLI and its bundled runtimes
- The pattern is identical for all index types (methods, observations, governance)

## Alternatives Considered

### Alternative 1: Build Indices at Container Startup

**Description**: Include Bun and build tools in the runtime image; build indices when the container starts.

**Pros**:
- Single-stage Dockerfile (simpler)
- Indices are always fresh

**Cons**:
- 2+ seconds startup delay on every container launch
- Runtime image includes unnecessary build tools (~300MB+ larger)
- Startup failures if build tools have issues
- Increased attack surface

**Why Rejected**: Startup delay is unacceptable for CI/CD integration where many scans run sequentially. The larger image size and attack surface are also concerns.

### Alternative 2: Mount Indices as Docker Volume

**Description**: Build indices on the host machine; mount the output directory as a Docker volume.

**Pros**:
- Decouples index building from container image
- Can update indices without rebuilding the image

**Cons**:
- Requires the host to have Bun and build tools installed
- Adds a manual step before running the scanner
- Indices might be stale if the host doesn't rebuild
- Breaks the "single docker run" usage pattern

**Why Rejected**: The scanner is designed for simple `docker run` invocation in CI/CD. Requiring a pre-build step on the host defeats the containerization benefit.

### Alternative 3: Sidecar Container

**Description**: Run a separate builder container that produces indices, shared via a Docker volume with the scanner container.

**Pros**:
- Clean separation: builder container and scanner container have different lifecycle
- Can update indices independently

**Cons**:
- Requires Docker Compose or Kubernetes for orchestration
- More complex deployment model
- Volume sharing adds coordination complexity

**Why Rejected**: Over-engineering for a batch job that runs as a single container. Multi-stage build achieves the same separation within a single `docker build`.

## Implementation Notes

- Scanner Dockerfile: `packages/foe-scanner/Dockerfile`
- Unified container Dockerfile: `Dockerfile` (at repo root) also uses multi-stage with `oven/bun:1`
- Stage 1 copies `packages/foe-schemas/` and `packages/foe-field-guide-tools/` only
- Stage 2 copies specific output files: `methods-index.json`, `observations-index.json`
- ROAD-006 will add a third index file: `governance-index.json`

## References

- [Scanner Dockerfile](../../packages/foe-scanner/Dockerfile)
- [Root Dockerfile](../../Dockerfile)
- [Docker Multi-Stage Build Docs](https://docs.docker.com/build/building/multi-stage/)

## Compliance

This ADR affects the following areas:
- **Road Items**: ROAD-006
- **NFRs**: NFR-PERF-001 (index build must complete in &lt;5s)
- **BDD Scenarios**: N/A (infrastructure decision)

---

**Template Version**: 1.0.0
**Last Updated**: 2026-02-06
