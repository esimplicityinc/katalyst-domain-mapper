---
id: ADR-012
title: "Dual ID Strategy: UUIDs for API/DB, Slugs for Governance Docs"
status: accepted
category: architecture
scope: project-wide
created: "2026-02-09"
updated: "2026-02-09"
author: "Katalyst Team"
supersedes: ""
superseded_by: ""
---

# ADR-012: Dual ID Strategy: UUIDs for API/DB, Slugs for Governance Docs

## Status

**Accepted** - 2026-02-09

## Context

The project has two distinct systems that identify DDD artifacts, and they have fundamentally different requirements:

**1. API/DB Layer (existing, working):**
- Uses UUIDs (`z.string().uuid()`) for all DDD artifact IDs
- 15 usages across 7 schema files
- 6 `crypto.randomUUID()` calls in route handlers
- All DB columns are `TEXT` primary keys storing UUIDs
- Standard for auto-generated, globally unique database identifiers

**2. Governance/Docs Layer (planned, ROAD-003):**
- Markdown files with YAML frontmatter, parsed at build time
- Human authors write and maintain these files
- Cross-references between artifacts (e.g., an aggregate references its bounded context)
- Files are named by slug (e.g., `contexts/scanning.md`, `aggregates/escrow.md`)

ROAD-003's acceptance criterion #6 originally proposed prefixed IDs (`CTX-xxx`, `AGG-xxx`, `VO-xxx`, `EVT-xxx`) for governance schemas. However, ROAD-003's companion plan (`ddd-schemas.md`) uses plain slugs for cross-referencing between artifacts, creating a contradiction. Meanwhile, the API/DB layer already works with UUIDs and has no need to change.

The two systems serve different purposes: the API/DB layer is for interactive domain modeling through a web interface; the governance/docs layer is for markdown frontmatter parsed and validated at build time.

## Decision

Adopt a **dual ID strategy** where each system uses the ID format natural to its use case:

**1. API/DB Layer — UUIDs (unchanged):**
- Primary keys: `z.string().uuid()`
- Foreign keys: `z.string().uuid()`
- Generated via `crypto.randomUUID()`
- Standard, globally unique, machine-friendly

**2. Governance/Docs Layer — Slugs (new):**
- Format: `z.string().regex(/^[a-z0-9-]+$/)`
- Derived from markdown filenames (e.g., `contexts/scanning.md` → slug `scanning`)
- Human-readable, human-writable
- Cross-references use slugs (e.g., an aggregate's `context` field contains `scanning`, not a UUID)

ROAD-003's acceptance criterion #6 should be updated from `z.string().regex(/^CTX-\w+$/)` to slug-based cross-referencing per this ADR.

## Consequences

### Positive

- Zero changes to existing working API/DB code — UUIDs remain as-is
- Human-readable governance docs — authors write `context: scanning` not `context: 550e8400-e29b-41d4-a716-446655440000`
- Clean separation of concerns — each system uses the ID format natural to its domain
- Slug format matches markdown filename conventions already in use
- No migration needed for existing data

### Negative

- Two ID systems means translating between them if governance artifacts ever need to reference API entities (or vice versa). This is a future concern for ROAD-005+.
- Developers must understand which ID format to use in which context

### Neutral

- The DB columns are already `TEXT` type, so they could technically accept either format — the distinction is enforced at the schema/validation level, not the storage level
- The API artifacts also have a `name` field that serves as a human-readable identifier, partially overlapping with slug semantics
- Slugs must be unique within their artifact type (e.g., no two bounded contexts can share a slug), enforced by the index builder (ROAD-004)

## Alternatives Considered

### Alternative 1: Prefixed IDs Everywhere (CTX-xxx, AGG-xxx)

**Description**: Use prefixed, type-scoped IDs across both API/DB and governance layers.

**Pros**:
- Single ID format across the entire system
- Type prefix provides instant identification of artifact kind
- Consistent cross-referencing

**Cons**:
- Requires migrating all existing API/DB code (10+ files with UUID generation)
- Requires migrating existing database data
- Contradicts ROAD-003's own companion plan (`ddd-schemas.md`) which uses slugs
- Prefixed IDs are neither standard UUIDs nor human-friendly slugs — a compromise that serves neither use case well

**Why Rejected**: High migration cost for existing working code, contradicts the companion plan, and the prefix format doesn't serve either use case optimally.

### Alternative 2: UUIDs Everywhere

**Description**: Use UUIDs for both API/DB and governance markdown frontmatter.

**Pros**:
- Single ID format, no translation needed
- Globally unique, no collision risk
- Already working in the API/DB layer

**Cons**:
- UUIDs in markdown frontmatter are hostile to human authors (`context: 550e8400-e29b-41d4-a716-446655440000` vs. `context: scanning`)
- Defeats the purpose of human-authored governance docs
- Authors would need to look up UUIDs to write cross-references
- Markdown filenames would still be slug-based, creating a disconnect

**Why Rejected**: UUIDs are machine-friendly but human-hostile. Governance docs are authored by humans and should prioritize readability.

### Alternative 3: Hybrid Prefixed Slugs (CTX-scanning, AGG-escrow)

**Description**: Use slugs with a type prefix for governance docs.

**Pros**:
- Human-readable with type context
- Unique across all artifact types (not just within a type)

**Cons**:
- DDD artifacts are already namespaced by directory and schema type — the prefix is redundant (`contexts/scanning.md` with `id: CTX-scanning` duplicates the "context" information)
- More verbose for cross-references (`context: CTX-scanning` vs. `context: scanning`)
- Adds a parsing step to extract the slug from the prefix

**Why Rejected**: The type prefix is redundant with the directory structure and schema validation. Plain slugs are simpler and sufficient.

## Implementation Notes

- **Existing API/DB code**: No changes required. UUIDs remain as-is.
- **ROAD-003 acceptance criterion #6**: Updated from `z.string().regex(/^CTX-\w+$/)` to slug-based cross-referencing (`z.string().regex(/^[a-z0-9-]+$/)`)
- **ROAD-003 technical approach**: File tree comments updated from `CTX-xxx schema` to `Slug-based bounded context schema` (and similar for other artifact types)
- **Governance schemas (when built)**: Will use `z.string().regex(/^[a-z0-9-]+$/)` for ID and cross-reference fields
- **Index builder (ROAD-004)**: Will enforce slug uniqueness within each artifact type
- **Future bridge (ROAD-005+)**: If API entities need to reference governance artifacts, a mapping layer can be introduced

## References

- [ROAD-003: DDD Artifact Schemas](../roads/ROAD-003.md)
- [ROAD-004: Governance Parsers & Index Builder](../roads/ROAD-004.md)
- [DDD Schemas Plan](../plans/ddd-schemas.md)
- [Existing API DDD Schemas](../../foe-schemas/src/ddd/)
- [ADR-002: Zod as Schema Authority](./ADR-002.md)

## Compliance

This ADR affects the following areas:
- **Road Items**: ROAD-003, ROAD-004, ROAD-008
- **NFRs**: NFR-MAINT-001 (Cross-Reference Referential Integrity)
- **BDD Scenarios**: None currently affected

---

**Template Version**: 1.0.0
**Last Updated**: 2026-02-09
