---
id: ADR-003
title: "Hexagonal Architecture (Ports & Adapters)"
status: accepted
category: architecture
scope: "@foe/api"
created: "2026-02-06"
updated: "2026-02-06"
author: "Katalyst Team"
supersedes: ""
superseded_by: ""
---

# ADR-003: Hexagonal Architecture (Ports & Adapters)

## Status

**Accepted** - 2026-02-06

## Context

The `@foe/api` package provides a REST API for scan orchestration, report storage, governance snapshot management, and domain model queries. The API needs to:

1. Be testable in isolation (unit tests without starting a server or database)
2. Support swapping infrastructure (SQLite today, potentially PostgreSQL or a cloud database later)
3. Keep domain/business logic independent of HTTP framework and persistence technology
4. Support multiple adapter implementations (in-memory for tests, SQLite for production, Docker for scan execution)

A flat architecture (routes directly calling database queries) would couple business logic to infrastructure, making testing and future migration difficult.

## Decision

Use **Hexagonal Architecture** (Ports & Adapters) for the `@foe/api` package:

- **Ports** (`src/ports/`): TypeScript interfaces defining contracts (e.g., `ReportRepository`, `ScanJobRepository`, `ScanRunner`, `Logger`)
- **Adapters** (`src/adapters/`): Concrete implementations of ports (e.g., `ReportRepositorySQLite`, `DockerScanRunner`, `InMemoryReportRepository`)
- **Use Cases** (`src/usecases/`): Business logic orchestration (e.g., `TriggerScan`, `IngestReport`, `GetReport`, `CompareReports`)
- **Domain** (`src/domain/`): Core entities, value objects, and error types
- **HTTP Routes** (`src/http/routes/`): Thin HTTP handlers that delegate to use cases
- **Bootstrap** (`src/bootstrap/`): Dependency injection container that wires ports to adapters

Dependency direction: Routes → Use Cases → Ports ← Adapters. The domain never depends on infrastructure.

## Consequences

### Positive

- Use cases can be unit tested with in-memory adapters (no database, no Docker)
- Infrastructure is swappable: changing from SQLite to PostgreSQL only requires a new adapter
- Clear separation of concerns: HTTP handling, business logic, and persistence are isolated
- The scanner agent (ROAD-006) can inject a different `ScanRunner` adapter without changing use cases
- New adapters (e.g., `GovernanceRepositorySQLite` for ROAD-005) follow the established pattern

### Negative

- More files and indirection compared to a flat architecture (port interface + adapter + use case vs. a single route handler)
- New team members must understand the hexagonal pattern before contributing
- Port interfaces add a layer of abstraction that may feel over-engineered for simple CRUD operations

### Neutral

- The pattern is well-documented in the `.opencode/skills/clean-ddd-hexagonal/` skill
- AI agents (code-writer, architecture-inspector) are trained to follow this pattern

## Alternatives Considered

### Alternative 1: Flat Route Handlers

**Description**: Routes directly query the database and return responses. No ports, adapters, or use cases.

**Pros**:
- Fewer files, less indirection
- Faster initial development

**Cons**:
- Business logic mixed with HTTP handling and database queries
- Testing requires a running database
- No way to swap infrastructure without rewriting routes

**Why Rejected**: Testing becomes painful and infrastructure coupling prevents future evolution.

### Alternative 2: Layered Architecture (Controller-Service-Repository)

**Description**: Traditional 3-layer architecture with controllers, services, and repositories.

**Pros**:
- Well-understood pattern
- Clear separation into layers

**Cons**:
- Dependency direction flows top-to-bottom (controllers depend on services, services depend on repositories)
- Repositories are concrete, not interface-based, making swapping difficult
- No explicit "port" concept for external services (Docker, AI agents)

**Why Rejected**: Hexagonal architecture provides better inversion of control for the diverse adapter set (SQLite, Docker, in-memory, future cloud services).

### Alternative 3: Vertical Slice Architecture

**Description**: Organize by feature (each endpoint is a self-contained slice with its own handler, query, and model).

**Pros**:
- Each feature is self-contained
- Easy to add new features without touching existing code

**Cons**:
- Shared infrastructure (database connections, Docker runner) requires cross-slice coordination
- Less natural for a REST API where many endpoints share the same domain entities

**Why Rejected**: The API has significant shared infrastructure (SQLite connection, Docker runner, report validation) that benefits from centralized port definitions rather than per-slice duplication.

## Implementation Notes

- Bootstrap container (`src/bootstrap/container.ts`) wires all ports to adapters at startup
- Test setup creates a container with in-memory adapters: `InMemoryReportRepository`, `InMemoryScanJobRepository`
- Drizzle ORM is used only within SQLite adapters; use cases and ports know nothing about Drizzle
- The `GovernanceRepository` port (ROAD-005) will follow the same pattern as `ReportRepository`

## References

- [Hexagonal Architecture Skill](../../.opencode/skills/clean-ddd-hexagonal/SKILL.md)
- [@foe/api ports directory](../../packages/foe-api/src/ports/)
- [@foe/api adapters directory](../../packages/foe-api/src/adapters/)
- [API Governance Domain Plan](../plans/api-governance-domain.md)

## Compliance

This ADR affects the following areas:
- **Road Items**: ROAD-005
- **NFRs**: NFR-PERF-002 (API Response Time), NFR-REL-001 (Schema Validation at Boundaries)
- **BDD Scenarios**: API feature files in `stack-tests/features/api/`

---

**Template Version**: 1.0.0
**Last Updated**: 2026-02-06
