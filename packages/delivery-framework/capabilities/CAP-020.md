---
id: CAP-020
title: "Hexagonal Architecture Foundation"
tag: "@CAP-020"
category: Technical
status: stable
description: "Consistent ports/adapters/use-cases pattern across all bounded contexts enabling independent testing, swappable persistence, and domain validation."
---

# CAP-020: Hexagonal Architecture Foundation

## Description

The system enforces a consistent hexagonal (ports and adapters) architecture across all bounded contexts. Every bounded context — Reports, Governance, Taxonomy, Domain Modeling — follows an identical structural pattern: domain objects encapsulate validation logic, use cases orchestrate business rules, port interfaces define contracts, and adapters implement persistence. This uniformity enables independent testing of business logic without database dependencies, swappable persistence backends, and predictable code organization.

The architecture separates concerns into concentric layers. At the core, domain objects enforce invariants (e.g., workflow state machines reject invalid transitions, taxonomy entities validate parent references). Use cases compose domain objects and repository calls into application-level operations (e.g., `CreateDomainModel`, `GetDomainModelWithArtifacts`, `ManageWorkflows`). Port interfaces define the boundary — repository contracts that adapters must implement. SQLite adapters using Drizzle ORM provide the current persistence implementation, but the port abstraction means any storage backend (PostgreSQL, file system, in-memory) can be substituted without touching business logic.

Route handlers are kept intentionally thin — under 250 lines per bounded context — responsible only for HTTP parsing, calling use cases, and formatting responses. Dependency injection is wired through a central `bootstrap/container.ts` module that instantiates adapters and injects them into use cases at application startup.

## Key Features

- **Port Interfaces**: Repository interfaces for each bounded context (`ReportRepository`, `GovernanceRepository`, `TaxonomyRepository`, `DomainModelRepository`) defining query and mutation contracts
- **SQLite Adapters**: Drizzle ORM implementations of all ports with migration support, transaction isolation, and connection pooling
- **Use Cases**: Extracted business logic encapsulated in single-responsibility classes (`CreateDomainModel`, `GetDomainModelWithArtifacts`, `ManageWorkflows`, `ValidateGovernanceRules`, etc.)
- **Domain Objects**: Validation logic enforced at the domain layer (workflow state machine integrity, no orphan transitions, taxonomy referential integrity, report schema compliance)
- **Thin Route Handlers**: HTTP layer kept under 250 lines per bounded context, responsible only for request parsing, use case invocation, and response formatting
- **Container Wiring**: Dependency injection via `bootstrap/container.ts` that instantiates adapters and injects them into use cases at startup

## Architecture

```
HTTP Layer (Route Handlers)
    ↓ thin — parses request, calls use case, formats response
Application Layer (Use Cases)
    ↓ orchestrates domain logic and repository calls
Domain Layer (Domain Objects)
    ↓ encapsulates invariants and validation
Port Layer (Repository Interfaces)
    ↓ defines contracts
Adapter Layer (SQLite / File / In-Memory)
    ↓ implements contracts

Bounded Contexts:
    ├── Reports     → ReportRepository      → ReportRepositorySQLite
    ├── Governance  → GovernanceRepository   → GovernanceRepositorySQLite
    ├── Taxonomy    → TaxonomyRepository     → DomainModelRepositorySQLite
    └── Domain      → DomainModelRepository  → DomainModelRepositorySQLite

Wiring:
    bootstrap/container.ts → instantiates adapters → injects into use cases
```

## NFR Requirements

- Architecture consistency score >= 80/100 (measured by structural lint rules)
- Unit test isolation: all use cases testable with in-memory repository stubs, no database required
- Route handler files < 250 lines per bounded context
- Zero circular dependencies between layers (domain never imports from adapters)

## Personas

- **PER-002** (Platform Engineer) — Maintains the codebase with confidence that architectural patterns are consistent and predictable across all bounded contexts
- **PER-003** (DevOps/CI Engineer) — Benefits from fast unit tests that don't require database setup, enabling reliable CI/CD pipelines
- **PER-005** (Framework Adopter) — Learns the hexagonal pattern once and applies it identically across all bounded contexts when extending the framework

## Related Capabilities

- **CAP-009** (DDD Domain Modeling API) — Primary bounded context demonstrating the hexagonal pattern with domain model CRUD, artifact management, and workflow state machines
- **CAP-013** (System Taxonomy Management) — Taxonomy bounded context following the same ports/adapters structure
- **CAP-001** (FOE Report Generation) — Reports bounded context with ReportRepository port and SQLite adapter

## Related Artifacts

- **User Stories**: US-063 (Hexagonal Architecture Consistency)
- **Road Items**: ROAD-027 (Hexagonal Architecture Foundation)
