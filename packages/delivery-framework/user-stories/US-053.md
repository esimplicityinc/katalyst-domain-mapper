---
id: US-053
title: Define Actions and Tools for Capabilities
actor: Platform Architect
goal: Define actions and tools that support capabilities to track implementation methods and tooling choices
benefit: Enables tooling analysis, action standardization, and identifies tool sprawl or gaps
capability: CAP-013
status: planned
priority: medium
roadmapItems:
  - ROAD-041
relatedStories:
  - US-051
  - US-052
created: 2026-02-17
updated: 2026-02-17
---

# US-053: Define Actions and Tools for Capabilities

## Story

**As a** Platform Architect  
**I want to** define actions and tools that support capabilities  
**So that** I can track implementation methods and standardize tooling choices across systems

## Acceptance Criteria

### Creating Actions

- [ ] Can create a new action with name, category, and description
- [ ] Can specify action category (e.g., "deployment", "testing", "monitoring")
- [ ] Can associate action with one or more capabilities
- [ ] System enforces unique action names
- [ ] System validates that all referenced capabilities exist

### Creating Tools

- [ ] Can create a new tool with name, version, and description
- [ ] Can specify tool category (e.g., "ci-cd", "monitoring", "testing-framework")
- [ ] Can associate tool with one or more actions
- [ ] Can track tool version and vendor
- [ ] System enforces unique tool names per version
- [ ] System validates that all referenced actions exist

### Creating Stages

- [ ] Can create deployment stages (e.g., "build", "test", "deploy", "monitor")
- [ ] Can define stage order and dependencies
- [ ] Can associate actions with specific stages
- [ ] System prevents circular stage dependencies

### Updating Actions and Tools

- [ ] Can update action/tool name, category, and description
- [ ] Can add or remove capability/action associations
- [ ] Can update tool versions
- [ ] Changes are reflected in all related entities

### Deleting Actions and Tools

- [ ] Can delete an action not referenced by any tools or stages
- [ ] Can delete a tool not referenced by any stages
- [ ] System blocks deletion if references exist
- [ ] System provides list of blocking references

### Querying Actions and Tools

- [ ] Can list all actions with filtering by category
- [ ] Can list all tools with filtering by category
- [ ] Can retrieve action/tool by ID with all associations
- [ ] Can fetch all actions for a specific capability
- [ ] Can fetch all tools for a specific action
- [ ] Can view action-tool-stage relationships
- [ ] Can identify unused tools (not associated with any action)

## Implementation Notes

### API Endpoints (15 total)

#### Actions (5)
1. `POST /api/v1/taxonomy/actions` - Create action
2. `GET /api/v1/taxonomy/actions` - List actions (with filters)
3. `GET /api/v1/taxonomy/actions/:id` - Get action details
4. `PATCH /api/v1/taxonomy/actions/:id` - Update action
5. `DELETE /api/v1/taxonomy/actions/:id` - Delete action

#### Tools (5)
6. `POST /api/v1/taxonomy/tools` - Create tool
7. `GET /api/v1/taxonomy/tools` - List tools (with filters)
8. `GET /api/v1/taxonomy/tools/:id` - Get tool details
9. `PATCH /api/v1/taxonomy/tools/:id` - Update tool
10. `DELETE /api/v1/taxonomy/tools/:id` - Delete tool

#### Stages (5)
11. `POST /api/v1/taxonomy/stages` - Create stage
12. `GET /api/v1/taxonomy/stages` - List stages
13. `GET /api/v1/taxonomy/stages/:id` - Get stage details
14. `PATCH /api/v1/taxonomy/stages/:id` - Update stage
15. `DELETE /api/v1/taxonomy/stages/:id` - Delete stage

### Port Interface Methods

```typescript
// From TaxonomyRepository port

// Actions
createAction(action: Action): Promise<Action>
getActionById(id: string): Promise<Action | null>
getAllActions(filters?: ActionFilters): Promise<Action[]>
updateAction(id: string, updates: Partial<Action>): Promise<Action>
deleteAction(id: string): Promise<void>
getActionsForCapability(capabilityId: string): Promise<Action[]>

// Tools
createTool(tool: Tool): Promise<Tool>
getToolById(id: string): Promise<Tool | null>
getAllTools(filters?: ToolFilters): Promise<Tool[]>
updateTool(id: string, updates: Partial<Tool>): Promise<Tool>
deleteTool(id: string): Promise<void>
getToolsForAction(actionId: string): Promise<Tool[]>

// Stages
createStage(stage: Stage): Promise<Stage>
getStageById(id: string): Promise<Stage | null>
getAllStages(): Promise<Stage[]>
updateStage(id: string, updates: Partial<Stage>): Promise<Stage>
deleteStage(id: string): Promise<void>
getStageOrder(): Promise<Stage[]>
validateStageDependencies(stageId: string, dependsOnStageId: string): Promise<boolean>
```

### File-Based Adapter

Actions, tools, and stages stored in YAML files:

```
data/taxonomy/actions/
  ├── deploy-to-production.yaml
  ├── run-unit-tests.yaml
  └── monitor-performance.yaml

data/taxonomy/tools/
  ├── github-actions.yaml
  ├── jest.yaml
  └── datadog.yaml

data/taxonomy/stages/
  ├── build.yaml
  ├── test.yaml
  └── deploy.yaml
```

Action file format:
```yaml
id: action-001
name: Deploy to Production
category: deployment
description: Deploy application to production environment
capabilityIds:
  - cap-005  # CI/CD Automation
  - cap-012  # Production Deployment
createdAt: 2026-02-17T10:00:00Z
updatedAt: 2026-02-17T10:00:00Z
```

Tool file format:
```yaml
id: tool-001
name: GitHub Actions
version: 2024
category: ci-cd
description: Cloud-based CI/CD automation platform
vendor: GitHub
actionIds:
  - action-001  # Deploy to Production
  - action-005  # Run Integration Tests
createdAt: 2026-02-17T10:00:00Z
updatedAt: 2026-02-17T10:00:00Z
```

Stage file format:
```yaml
id: stage-003
name: Deploy
order: 3
description: Deploy application to target environment
dependsOn:
  - stage-002  # Test stage must complete first
actionIds:
  - action-001  # Deploy to Production
  - action-002  # Deploy to Staging
createdAt: 2026-02-17T10:00:00Z
updatedAt: 2026-02-17T10:00:00Z
```

## UI Components

### Action Management Page

- List view of all actions
- Filter by category
- Add/Edit/Delete buttons
- Search by name
- Show associated capabilities and tools

### Tool Management Page

- List view of all tools
- Filter by category or vendor
- Add/Edit/Delete buttons
- Search by name
- Show associated actions
- Highlight unused tools (red badge)

### Stage Management Page

- Visual pipeline view showing stage order
- Drag-and-drop to reorder stages
- Add/Edit/Delete buttons
- Show actions per stage
- Validate dependencies (prevent cycles)

### Action-Tool-Stage Relationship Diagram

- Interactive graph visualization
- Color-coded by category
- Shows: Capability → Action → Tool → Stage
- Clickable nodes to navigate
- Export to PNG/SVG

## BDD Scenarios

```gherkin
@US-053 @CAP-013 @ROAD-041
Feature: Manage Actions, Tools, and Stages

  Background:
    Given I am authenticated as a Platform Architect
    And the taxonomy repository is initialized
    And capabilities exist:
      | id    | name                |
      | cap-1 | CI/CD Automation    |
      | cap-2 | Production Deployment |

  Scenario: Create an action for deployment
    When I create an action with:
      | name         | Deploy to Production              |
      | category     | deployment                        |
      | description  | Deploy app to production env      |
      | capabilities | cap-1, cap-2                      |
    Then the action is created successfully
    And the action has a unique ID
    And the action is associated with capabilities "CI/CD Automation", "Production Deployment"

  Scenario: Prevent duplicate action names
    Given an action "Deploy to Production" exists
    When I try to create another action "Deploy to Production"
    Then the creation fails with error "Action name already exists"

  Scenario: Create a tool for CI/CD
    Given an action "Deploy to Production" exists with ID "action-1"
    When I create a tool with:
      | name        | GitHub Actions       |
      | version     | 2024                 |
      | category    | ci-cd                |
      | description | CI/CD platform       |
      | vendor      | GitHub               |
      | actions     | action-1             |
    Then the tool is created successfully
    And the tool is associated with action "Deploy to Production"

  Scenario: Create deployment stages with dependencies
    Given actions exist:
      | id       | name                   |
      | action-1 | Build Application      |
      | action-2 | Run Tests              |
      | action-3 | Deploy to Production   |
    When I create stages:
      | name   | order | dependsOn | actions  |
      | Build  | 1     |           | action-1 |
      | Test   | 2     | Build     | action-2 |
      | Deploy | 3     | Test      | action-3 |
    Then all stages are created successfully
    And stage "Test" depends on "Build"
    And stage "Deploy" depends on "Test"

  Scenario: Prevent circular stage dependencies
    Given stages exist:
      | id      | name   | dependsOn |
      | stage-1 | Build  |           |
      | stage-2 | Test   | stage-1   |
    When I try to update stage "Build" to depend on "Test"
    Then the update fails with error "Circular dependency detected"
    And the error shows cycle: Build → Test → Build

  Scenario: List all actions for a capability
    Given actions exist:
      | name                   | category   | capabilities |
      | Deploy to Production   | deployment | cap-1        |
      | Run Unit Tests         | testing    | cap-1        |
      | Monitor Performance    | monitoring | cap-2        |
    When I list actions for capability "cap-1" (CI/CD Automation)
    Then I see 2 actions: "Deploy to Production", "Run Unit Tests"

  Scenario: List all tools for an action
    Given an action "Deploy to Production" exists with ID "action-1"
    And tools exist:
      | name            | category | actions  |
      | GitHub Actions  | ci-cd    | action-1 |
      | GitLab CI       | ci-cd    | action-1 |
      | Jenkins         | ci-cd    |          |
    When I list tools for action "Deploy to Production"
    Then I see 2 tools: "GitHub Actions", "GitLab CI"

  Scenario: Identify unused tools
    Given tools exist:
      | name            | actions  |
      | GitHub Actions  | action-1 |
      | Unused Tool     |          |
    When I list all tools
    Then "Unused Tool" is marked as unused
    And I receive a warning: "Tool not associated with any action"

  Scenario: Block action deletion with tool references
    Given an action "Deploy to Production" exists with ID "action-1"
    And a tool "GitHub Actions" references action "action-1"
    When I try to delete action "action-1"
    Then the deletion fails with error "Action is referenced by tools"
    And the error lists: "GitHub Actions"

  Scenario: Delete action after removing tool references
    Given an action "Deploy to Production" exists with ID "action-1"
    And a tool "GitHub Actions" references action "action-1"
    When I remove action "action-1" from tool "GitHub Actions"
    And I delete action "action-1"
    Then the action is deleted successfully

  Scenario: Filter actions by category
    Given actions exist:
      | name                | category   |
      | Deploy to Production| deployment |
      | Run Unit Tests      | testing    |
      | Monitor Performance | monitoring |
    When I filter actions by category "deployment"
    Then I see 1 action: "Deploy to Production"

  Scenario: Filter tools by vendor
    Given tools exist:
      | name            | vendor  |
      | GitHub Actions  | GitHub  |
      | GitLab CI       | GitLab  |
      | CircleCI        | CircleCI|
    When I filter tools by vendor "GitHub"
    Then I see 1 tool: "GitHub Actions"

  Scenario: View stage pipeline order
    Given stages exist:
      | name   | order |
      | Build  | 1     |
      | Test   | 2     |
      | Deploy | 3     |
    When I view the stage pipeline
    Then I see stages in order: "Build", "Test", "Deploy"

  Scenario: Update tool version
    Given a tool "GitHub Actions" with version "2023" exists
    When I update the tool version to "2024"
    Then the tool version is updated to "2024"
    And the tool's updatedAt timestamp is refreshed

  Scenario: Associate multiple tools with one action
    Given an action "Deploy to Production" exists
    And tools exist:
      | name            |
      | GitHub Actions  |
      | GitLab CI       |
    When I associate both tools with the action
    Then the action has 2 tools: "GitHub Actions", "GitLab CI"
    And both tools show the action in their associations

  Scenario: View action-tool-stage relationships
    Given the following relationships exist:
      | capability      | action               | tool           | stage  |
      | CI/CD Automation| Deploy to Production | GitHub Actions | Deploy |
    When I view the relationship diagram
    Then I see: CI/CD Automation → Deploy to Production → GitHub Actions → Deploy
```

## Dependencies

- **CAP-013**: System Taxonomy Management
- **ROAD-041**: Taxonomy CRUD Operations (Phase 1)
- **US-051**: Map Capabilities to Nodes (actions support capabilities)

## Related Stories

- **US-051**: Map Capabilities to Organizational Nodes
- **US-052**: Configure System Environments (actions can be environment-specific)

## Technical Notes

### Validation Rules

1. **Name uniqueness**: Action and tool names should be unique
2. **Capability/action existence**: All references must exist
3. **Stage dependencies**: Prevent circular dependencies
4. **Deletion protection**: Cannot delete if referenced by other entities

### Action Categories

Common action categories:

- **deployment**: Deploy, rollback, promote
- **testing**: Unit tests, integration tests, e2e tests
- **monitoring**: Performance monitoring, alerting, logging
- **security**: Vulnerability scanning, penetration testing
- **validation**: Code quality, linting, formatting

### Tool Categories

Common tool categories:

- **ci-cd**: GitHub Actions, GitLab CI, Jenkins, CircleCI
- **testing-framework**: Jest, Pytest, Selenium, Cypress
- **monitoring**: Datadog, New Relic, Prometheus, Grafana
- **security**: Snyk, SonarQube, OWASP ZAP
- **quality**: ESLint, Prettier, Black, RuboCop

### Stage Pattern

Standard CI/CD pipeline stages:

1. **Build**: Compile code, install dependencies
2. **Test**: Run automated tests
3. **Package**: Create artifacts (Docker images, binaries)
4. **Deploy**: Deploy to environment
5. **Verify**: Smoke tests, health checks
6. **Monitor**: Collect metrics, set up alerts

### Performance Considerations

- Index actions by `category` and `capabilityId`
- Index tools by `category`, `vendor`, and `actionId`
- Index stages by `order` for fast pipeline retrieval
- Cache stage dependency graph

### Dual Persistence

- **SQLite adapter**: Fast queries, referential integrity
- **File adapter**: Human-readable, version-controlled YAML
- Both adapters must implement same `TaxonomyRepository` port

### Integration with FOE Scanner

The FOE scanner can use action/tool mappings to:
- Detect tools used in repositories
- Recommend standardized tools
- Identify tool sprawl (too many tools for same purpose)
- Analyze pipeline maturity (presence of all standard stages)
- Track tool adoption across teams

### Example Query

**Find all tools used for deployment:**
```typescript
const deployActions = await taxonomyRepo.getAllActions({ category: 'deployment' });
const deployTools = new Set();

for (const action of deployActions) {
  const tools = await taxonomyRepo.getToolsForAction(action.id);
  tools.forEach(tool => deployTools.add(tool.name));
}

console.log(`Deployment tools in use: ${Array.from(deployTools).join(', ')}`);
```
